<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{SANDBOX_ID}} &mdash; Synapse </title>
  <style>
    :root {
      --bg: #0b0d11;
      --surface: #14171e;
      --surface-hover: #1a1e27;
      --border: #252a35;
      --text: #e4e7ed;
      --text-dim: #7a8194;
      --accent: #6c72cb;
      --accent-bright: #8187de;
      --green: #34d399;
      --red: #f87171;
      --radius: 12px;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
                   'Helvetica Neue', Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
    }

    .app {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: var(--bg);
    }
    .preview {
      position: relative;
      width: 100%;
      height: 100%;
      background: var(--bg);
    }
    .preview iframe {
      width: 100%;
      height: 100%;
      border: none;
      background: white;
    }

    .floating-toolbar {
      position: absolute;
      left: 50%;
      bottom: 24px;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(20, 23, 30, 0.96);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 8px;
      z-index: 30;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.35);
    }
    .toolbar-btn {
      width: 36px;
      height: 36px;
      border: 1px solid transparent;
      border-radius: 999px;
      background: transparent;
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all .15s;
    }
    .toolbar-btn:hover {
      background: var(--surface-hover);
      border-color: var(--border);
    }
    .toolbar-btn svg {
      width: 18px;
      height: 18px;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .loading-overlay {
      position: absolute; inset: 0;
      background: rgba(11,13,17,.85);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      gap: 14px; z-index: 10; backdrop-filter: blur(4px);
    }
    .loading-overlay.hidden { display: none; }
    .spinner {
      width: 28px; height: 28px; border: 3px solid var(--border);
      border-top-color: var(--accent-bright); border-radius: 50%;
      animation: spin .8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-overlay p { font-size: 12px; color: var(--text-dim); }
    .loading-overlay .refined-box {
      max-width: 320px; padding: 10px 14px; margin-top: 6px;
      background: rgba(20,23,30,.95); border: 1px solid var(--border);
      border-radius: 10px; text-align: left;
    }
    .loading-overlay .refined-label { font-size: 10px; color: var(--text-dim); margin-bottom: 4px; text-transform: uppercase; letter-spacing: .5px; }
    .loading-overlay .refined-text { font-size: 12px; color: var(--text); line-height: 1.45; }
    .loading-overlay .refined-from { font-size: 11px; color: var(--text-dim); margin-bottom: 6px; line-height: 1.4; }
    .message.refined-from {
      font-size: 11px; color: var(--text-dim); padding: 6px 10px;
      border-left: 3px solid var(--accent); background: var(--bg);
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="preview">
      <iframe id="previewFrame" src="about:blank"></iframe>
      <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <p id="loadingText">Starting sandbox...</p>
        <div class="refined-box" id="refinedBox" style="display: none;">
          <div class="refined-label" id="refinedStatus" style="display: none;"></div>
          <div class="refined-label">Gemini refinement</div>
          <div class="refined-from" id="refinedFrom" style="display: none;"></div>
          <div class="refined-label" id="refinedToLabel" style="display: none;">Sent to AI</div>
          <div class="refined-text" id="refinedText"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const SANDBOX_ID = '{{SANDBOX_ID}}';
    const BASE = '/s/' + SANDBOX_ID + '/';

    let generating = false;
    let currentFiles = [];

    const els = Object.fromEntries(
      ['previewFrame',
       'loadingOverlay','loadingText','statusDot','statusText',
       'urlInput','fileBar','refinedBox','refinedText','refinedFrom','refinedToLabel','refinedStatus'].map(id => [id, document.getElementById(id)])
    );

    function autoResize(el) {
      el.style.height = 'auto';
      el.style.height = Math.min(el.scrollHeight, 120) + 'px';
    }
    function handleKey(e) {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendPrompt(); }
    }
    function useSuggestion(el) {
      els.promptInput.value = el.textContent;
      els.sendBtn.disabled = false;
      els.promptInput.focus();
      sendPrompt();
    }

    function addMessage(text, type, fileList) {
    }

    function addRefinedFromMessage(rawPrompt, refinedPrompt) {
      return;
    }

    function setStatus(state, text) {
      return;
    }
    function showLoading(text, refinedPrompt, rawPrompt, refinementSkipped, refinementFailed, refinementError) {
      els.loadingText.textContent = text;
      els.loadingOverlay.classList.remove('hidden');
      if (els.refinedStatus) {
        if (refinementSkipped) {
          els.refinedStatus.textContent = 'Refinement skipped (no GEMINI_API_KEY in worker)';
          els.refinedStatus.style.display = 'block';
          els.refinedStatus.style.color = 'var(--warning, #b8860b)';
        } else if (refinementFailed) {
          els.refinedStatus.textContent = 'Refinement failed: ' + (refinementError || 'unknown error');
          els.refinedStatus.style.display = 'block';
          els.refinedStatus.style.color = 'var(--destructive, #dc2626)';
        } else {
          els.refinedStatus.style.display = 'none';
        }
      }
      if (refinedPrompt && els.refinedBox && els.refinedText) {
        els.refinedText.textContent = refinedPrompt;
        els.refinedBox.style.display = 'block';
        if (els.refinedFrom && els.refinedToLabel) {
          if (rawPrompt && rawPrompt !== refinedPrompt) {
            els.refinedFrom.textContent = 'From: ' + rawPrompt;
            els.refinedFrom.style.display = 'block';
            els.refinedToLabel.textContent = 'To (sent to AI):';
            els.refinedToLabel.style.display = 'block';
          } else {
            els.refinedFrom.style.display = 'none';
            els.refinedToLabel.textContent = 'Refined prompt sent to AI';
            els.refinedToLabel.style.display = 'block';
          }
        }
      } else if (els.refinedBox) {
        els.refinedBox.style.display = 'none';
        if (els.refinedFrom) els.refinedFrom.style.display = 'none';
        if (els.refinedToLabel) els.refinedToLabel.style.display = 'none';
      }
    }
    function hideLoading() {
      els.loadingOverlay.classList.add('hidden');
      if (els.refinedBox) els.refinedBox.style.display = 'none';
      if (els.refinedFrom) els.refinedFrom.style.display = 'none';
      if (els.refinedToLabel) els.refinedToLabel.style.display = 'none';
      if (els.refinedStatus) els.refinedStatus.style.display = 'none';
    }

    function renderFileTabs(files) {
      currentFiles = files;
    }

    function navigatePreview(path) {
      if (!path.startsWith('preview')) path = 'preview/' + path.replace(/^\/+/, '');
      const fullUrl = BASE + path + (path.includes('?') ? '&' : '?') + '_t=' + Date.now();
      els.previewFrame.src = fullUrl;
    }

    function reloadPreview() {
      const path = 'preview/';
      const fullUrl = BASE + path + (path.includes('?') ? '&' : '?') + '_t=' + Date.now();
      els.previewFrame.src = fullUrl;
    }

    async function initSandbox(attempt) {
      attempt = attempt || 1;
      const MAX = 3;
      setStatus('loading', 'Starting sandbox...');
      showLoading(attempt > 1
        ? 'Container is booting, retrying (' + attempt + '/' + MAX + ')...'
        : 'Starting sandbox container...');
      try {
        const res = await fetch(BASE + 'api/init', { method: 'POST' });
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        renderFileTabs(data.files || []);
        navigatePreview('preview/');
        setStatus('active', 'Sandbox ready');
        hideLoading();
      } catch (err) {
        if (attempt < MAX) {
          await new Promise(r => setTimeout(r, 3000 * attempt));
          return initSandbox(attempt + 1);
        }
        setStatus('', 'Error');
        showLoading('Failed to start: ' + err.message);
      }
    }

    async function doRefineRequest(prompt) {
      const res = await fetch(BASE + 'api/refine', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt }),
      });
      const data = await res.json().catch(() => ({}));
      var refined = data.refinedPrompt != null ? String(data.refinedPrompt).trim() : '';
      return {
        refinedPrompt: refined,
        refinementSkipped: !!data.refinementSkipped,
        refinementFailed: !!data.refinementFailed,
        refinementError: typeof data.refinementError === 'string' ? data.refinementError : null,
        refinementEmpty: !!data.refinementEmpty,
      };
    }

    async function doPromptRequest(prompt, refinedPrompt) {
      const res = await fetch(BASE + 'api/prompt', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt: refinedPrompt != null ? refinedPrompt : prompt,
          refinedPrompt: refinedPrompt != null ? refinedPrompt : undefined,
          history: history.slice(-6),
        }),
      });
      if (!res.ok && res.status >= 500) throw new Error('Server error (' + res.status + ')');
      const data = await res.json();
      if (data.error) throw new Error(data.error);
      return data;
    }

    async function sendPrompt() {
      const prompt = '';
      if (!prompt || generating) return;
      generating = true;
      els.sendBtn.disabled = true;
      els.promptInput.value = '';
      els.promptInput.style.height = 'auto';
      setStatus('loading', 'Generating...');
      showLoading('Refining prompt...');

      var refinedPrompt = '';
      var refinementSkipped = false;
      var refinementFailed = false;
      var refinementError = null;
      var refinementEmpty = false;
      try {
        var refineResult = await doRefineRequest(prompt);
        refinedPrompt = refineResult.refinedPrompt;
        refinementSkipped = refineResult.refinementSkipped;
        refinementFailed = refineResult.refinementFailed;
        refinementError = refineResult.refinementError;
        refinementEmpty = refineResult.refinementEmpty;
      } catch (e) {
        refinementFailed = true;
        refinementError = e && e.message ? e.message : 'Network or request error';
      }
      var isEmpty = refinementEmpty || !refinedPrompt || refinedPrompt.length < 2;
      console.log('[refine] input preview:', prompt.slice(0, 80) + (prompt.length > 80 ? '...' : ''), '| result:', isEmpty ? '(empty)' : refinedPrompt, '| skipping LLM:', isEmpty);

      if (isEmpty) {
        var noRequestMessage = refinedPrompt || 'Refinement returned nothing; not calling AI.';
        addMessage(noRequestMessage, 'user');
        history.push({ role: 'user', content: noRequestMessage });
        showLoading('No actionable request.', refinedPrompt || noRequestMessage, prompt, refinementSkipped, refinementFailed, refinementError);
        hideLoading();
        generating = false;
        els.sendBtn.disabled = true;
        return;
      }

      addMessage(refinedPrompt, 'user');
      if (prompt !== refinedPrompt) addRefinedFromMessage(prompt, refinedPrompt);
      history.push({ role: 'user', content: refinedPrompt });
      showLoading('AI is updating your app...', refinedPrompt, prompt, refinementSkipped, refinementFailed, refinementError);

      var data = null;
      var lastErr = null;
      for (var attempt = 1; attempt <= 2; attempt++) {
        try {
          if (attempt > 1) showLoading('Retrying (' + attempt + '/2)...', refinedPrompt, prompt, refinementSkipped, refinementFailed, refinementError);
          data = await doPromptRequest(prompt, refinedPrompt);
          break;
        } catch (err) {
          lastErr = err;
          if (attempt < 2) await new Promise(r => setTimeout(r, 2000));
        }
      }

      if (data) {
        var changedFiles = [...(data.written||[]), ...(data.deleted||[]).map(f => f+' (deleted)')];
        var responseText = 'Updated ' + changedFiles.length + ' file(s): ' + changedFiles.join(', ');
        history.push({ role: 'assistant', content: 'Updated: ' + changedFiles.join(', ') });
        addMessage('Updated ' + changedFiles.length + ' file(s)', 'system', changedFiles);
        if (data.files) renderFileTabs(data.files);
        setStatus('active', 'Sandbox ready');
        reloadPreview();
        hideLoading();
        if (window.parent !== window) {
          window.parent.postMessage({ type: 'SANDBOX_RESPONSE', text: responseText, success: true }, '*');
        }
      } else {
        var errText = 'Error: ' + (lastErr ? lastErr.message : 'Unknown error');
        addMessage(errText, 'error');
        setStatus('active', 'Sandbox ready');
        hideLoading();
        if (window.parent !== window) {
          window.parent.postMessage({ type: 'SANDBOX_RESPONSE', text: errText, success: false }, '*');
        }
      }
      generating = false;
      els.sendBtn.disabled = true;
    }

    window.addEventListener('message', function(event) {
      var d = event.data;
      if (!d || !d.type) return;
      if (d.type === 'VOICE_PROMPT' && d.text) {
        els.promptInput.value = d.text;
        els.sendBtn.disabled = false;
        autoResize(els.promptInput);
        sendPrompt();
        return;
      }
      if (d.type === 'POSTHOG_INIT') {
        window.__POSTHOG_PREVIEW_CONFIG__ = { apiKey: d.apiKey, apiHost: d.apiHost || 'https://us.i.posthog.com', sandboxId: d.sandboxId };
        sendPostHogToPreview();
        return;
      }
      if (d.type === 'POSTHOG_STOP') {
        try {
          if (els.previewFrame && els.previewFrame.contentWindow) {
            els.previewFrame.contentWindow.postMessage({ type: 'POSTHOG_STOP' }, '*');
          }
        } catch (e) {}
        return;
      }
    });

    function sendPostHogToPreview() {
      try {
        var c = window.__POSTHOG_PREVIEW_CONFIG__;
        if (c && els.previewFrame && els.previewFrame.contentWindow) {
          els.previewFrame.contentWindow.postMessage({
            type: 'POSTHOG_INIT',
            apiKey: c.apiKey,
            apiHost: c.apiHost,
            sandboxId: c.sandboxId,
            isPreview: true
          }, '*');
        }
      } catch (e) {}
    }
    els.previewFrame.addEventListener('load', sendPostHogToPreview);

    initSandbox();

    // Session recording happens inside the preview iframe â€” see worker/src/index.ts.
  </script>
</body>
</html>
